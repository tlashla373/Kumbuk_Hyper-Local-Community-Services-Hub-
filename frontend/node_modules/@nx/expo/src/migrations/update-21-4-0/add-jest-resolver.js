"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = addJestResolver;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const update_tsconfig_files_1 = require("../../utils/update-tsconfig-files");
const expo_project_detection_1 = require("../../utils/expo-project-detection");
async function addJestResolver(tree) {
    const projects = (0, devkit_1.getProjects)(tree);
    for (const [, config] of projects) {
        if (config.targets?.test?.executor === '@nx/jest:jest') {
            // Check if this is an Expo project
            const expoProjectDetectionResult = (0, expo_project_detection_1.isExpoProject)(tree, config.root);
            if (!(await expoProjectDetectionResult).isExpo) {
                continue;
            }
            // Check if this is an Expo project by looking for jest.config file with expo preset
            const jestConfigPath = (0, path_1.join)(config.root, 'jest.config.ts');
            const jestConfigJsPath = (0, path_1.join)(config.root, 'jest.config.js');
            let jestConfigContent = '';
            let configPath = '';
            if (tree.exists(jestConfigPath)) {
                jestConfigContent = tree.read(jestConfigPath, 'utf-8');
                configPath = jestConfigPath;
            }
            else if (tree.exists(jestConfigJsPath)) {
                jestConfigContent = tree.read(jestConfigJsPath, 'utf-8');
                configPath = jestConfigJsPath;
            }
            if (jestConfigContent && jestConfigContent.includes('jest-expo')) {
                // This is an Expo project with Jest configuration
                const resolverPath = (0, path_1.join)(config.root, 'jest.resolver.js');
                // Create the custom resolver if it doesn't exist
                if (!tree.exists(resolverPath)) {
                    const resolverContent = `const defaultResolver = require('@nx/jest/plugins/resolver');

module.exports = (request, options) => {
  // Check if we're resolving from the winter directory and request is for runtime
  if (options.basedir && options.basedir.includes('expo/src/winter') && request === './runtime') {
    // Force resolution to non-native version to avoid runtime.native.ts
    return defaultResolver('./runtime.ts', options);
  }
  
  return defaultResolver(request, options);
};`;
                    tree.write(resolverPath, resolverContent);
                }
                // Update Jest config to use custom resolver
                if (configPath && jestConfigContent) {
                    const updatedConfig = jestConfigContent.replace(/resolver:\s*['"]@nx\/jest\/plugins\/resolver['"],?/, "resolver: require.resolve('./jest.resolver.js'),");
                    tree.write(configPath, updatedConfig);
                }
                // Update tsconfig files to handle jest.resolver.js properly
                (0, update_tsconfig_files_1.updateTsConfigFiles)(tree, config.name, config.root);
            }
        }
    }
    await (0, devkit_1.formatFiles)(tree);
}
